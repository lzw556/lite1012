// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: server/adapter/iot/proto/theta.proto

package theta

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ByeMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ByeMessage) Reset()         { *m = ByeMessage{} }
func (m *ByeMessage) String() string { return proto.CompactTextString(m) }
func (*ByeMessage) ProtoMessage()    {}
func (*ByeMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{0}
}
func (m *ByeMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ByeMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ByeMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ByeMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ByeMessage.Merge(m, src)
}
func (m *ByeMessage) XXX_Size() int {
	return m.Size()
}
func (m *ByeMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ByeMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ByeMessage proto.InternalMessageInfo

func (m *ByeMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ByeMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

type LinkStatusMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	Status               string   `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LinkStatusMessage) Reset()         { *m = LinkStatusMessage{} }
func (m *LinkStatusMessage) String() string { return proto.CompactTextString(m) }
func (*LinkStatusMessage) ProtoMessage()    {}
func (*LinkStatusMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{1}
}
func (m *LinkStatusMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkStatusMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkStatusMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkStatusMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkStatusMessage.Merge(m, src)
}
func (m *LinkStatusMessage) XXX_Size() int {
	return m.Size()
}
func (m *LinkStatusMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkStatusMessage.DiscardUnknown(m)
}

var xxx_messageInfo_LinkStatusMessage proto.InternalMessageInfo

func (m *LinkStatusMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *LinkStatusMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *LinkStatusMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *LinkStatusMessage) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

type LinkStatesMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	States               string   `protobuf:"bytes,4,opt,name=states,proto3" json:"states,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LinkStatesMessage) Reset()         { *m = LinkStatesMessage{} }
func (m *LinkStatesMessage) String() string { return proto.CompactTextString(m) }
func (*LinkStatesMessage) ProtoMessage()    {}
func (*LinkStatesMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{2}
}
func (m *LinkStatesMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LinkStatesMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LinkStatesMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LinkStatesMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkStatesMessage.Merge(m, src)
}
func (m *LinkStatesMessage) XXX_Size() int {
	return m.Size()
}
func (m *LinkStatesMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkStatesMessage.DiscardUnknown(m)
}

var xxx_messageInfo_LinkStatesMessage proto.InternalMessageInfo

func (m *LinkStatesMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *LinkStatesMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *LinkStatesMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *LinkStatesMessage) GetStates() string {
	if m != nil {
		return m.States
	}
	return ""
}

type GeneralStatusMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	DataLength           int32    `protobuf:"varint,4,opt,name=dataLength,proto3" json:"dataLength,omitempty"`
	Data                 []byte   `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GeneralStatusMessage) Reset()         { *m = GeneralStatusMessage{} }
func (m *GeneralStatusMessage) String() string { return proto.CompactTextString(m) }
func (*GeneralStatusMessage) ProtoMessage()    {}
func (*GeneralStatusMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{3}
}
func (m *GeneralStatusMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeneralStatusMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeneralStatusMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GeneralStatusMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeneralStatusMessage.Merge(m, src)
}
func (m *GeneralStatusMessage) XXX_Size() int {
	return m.Size()
}
func (m *GeneralStatusMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_GeneralStatusMessage.DiscardUnknown(m)
}

var xxx_messageInfo_GeneralStatusMessage proto.InternalMessageInfo

func (m *GeneralStatusMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *GeneralStatusMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GeneralStatusMessage) GetDataLength() int32 {
	if m != nil {
		return m.DataLength
	}
	return 0
}

func (m *GeneralStatusMessage) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type EventMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	Type                 int32    `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
	Severity             int32    `protobuf:"varint,5,opt,name=severity,proto3" json:"severity,omitempty"`
	DataLength           int32    `protobuf:"varint,6,opt,name=dataLength,proto3" json:"dataLength,omitempty"`
	Data                 []byte   `protobuf:"bytes,7,opt,name=data,proto3" json:"data,omitempty"`
	Message              string   `protobuf:"bytes,8,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EventMessage) Reset()         { *m = EventMessage{} }
func (m *EventMessage) String() string { return proto.CompactTextString(m) }
func (*EventMessage) ProtoMessage()    {}
func (*EventMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{4}
}
func (m *EventMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMessage.Merge(m, src)
}
func (m *EventMessage) XXX_Size() int {
	return m.Size()
}
func (m *EventMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMessage.DiscardUnknown(m)
}

var xxx_messageInfo_EventMessage proto.InternalMessageInfo

func (m *EventMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *EventMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *EventMessage) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *EventMessage) GetSeverity() int32 {
	if m != nil {
		return m.Severity
	}
	return 0
}

func (m *EventMessage) GetDataLength() int32 {
	if m != nil {
		return m.DataLength
	}
	return 0
}

func (m *EventMessage) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *EventMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type DeviceInformationMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	Information          string   `protobuf:"bytes,4,opt,name=information,proto3" json:"information,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceInformationMessage) Reset()         { *m = DeviceInformationMessage{} }
func (m *DeviceInformationMessage) String() string { return proto.CompactTextString(m) }
func (*DeviceInformationMessage) ProtoMessage()    {}
func (*DeviceInformationMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{5}
}
func (m *DeviceInformationMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceInformationMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceInformationMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceInformationMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceInformationMessage.Merge(m, src)
}
func (m *DeviceInformationMessage) XXX_Size() int {
	return m.Size()
}
func (m *DeviceInformationMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceInformationMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceInformationMessage proto.InternalMessageInfo

func (m *DeviceInformationMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *DeviceInformationMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *DeviceInformationMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *DeviceInformationMessage) GetInformation() string {
	if m != nil {
		return m.Information
	}
	return ""
}

type DeviceSettingsMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	Settings             string   `protobuf:"bytes,4,opt,name=settings,proto3" json:"settings,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceSettingsMessage) Reset()         { *m = DeviceSettingsMessage{} }
func (m *DeviceSettingsMessage) String() string { return proto.CompactTextString(m) }
func (*DeviceSettingsMessage) ProtoMessage()    {}
func (*DeviceSettingsMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{6}
}
func (m *DeviceSettingsMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceSettingsMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceSettingsMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceSettingsMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceSettingsMessage.Merge(m, src)
}
func (m *DeviceSettingsMessage) XXX_Size() int {
	return m.Size()
}
func (m *DeviceSettingsMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceSettingsMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceSettingsMessage proto.InternalMessageInfo

func (m *DeviceSettingsMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *DeviceSettingsMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *DeviceSettingsMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *DeviceSettingsMessage) GetSettings() string {
	if m != nil {
		return m.Settings
	}
	return ""
}

type DeviceMultipartSettingsMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	Settings             string   `protobuf:"bytes,4,opt,name=settings,proto3" json:"settings,omitempty"`
	NumberOfSegments     int32    `protobuf:"varint,5,opt,name=numberOfSegments,proto3" json:"numberOfSegments,omitempty"`
	SegmentIndex         int32    `protobuf:"varint,6,opt,name=segmentIndex,proto3" json:"segmentIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceMultipartSettingsMessage) Reset()         { *m = DeviceMultipartSettingsMessage{} }
func (m *DeviceMultipartSettingsMessage) String() string { return proto.CompactTextString(m) }
func (*DeviceMultipartSettingsMessage) ProtoMessage()    {}
func (*DeviceMultipartSettingsMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{7}
}
func (m *DeviceMultipartSettingsMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceMultipartSettingsMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceMultipartSettingsMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceMultipartSettingsMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceMultipartSettingsMessage.Merge(m, src)
}
func (m *DeviceMultipartSettingsMessage) XXX_Size() int {
	return m.Size()
}
func (m *DeviceMultipartSettingsMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceMultipartSettingsMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceMultipartSettingsMessage proto.InternalMessageInfo

func (m *DeviceMultipartSettingsMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *DeviceMultipartSettingsMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *DeviceMultipartSettingsMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *DeviceMultipartSettingsMessage) GetSettings() string {
	if m != nil {
		return m.Settings
	}
	return ""
}

func (m *DeviceMultipartSettingsMessage) GetNumberOfSegments() int32 {
	if m != nil {
		return m.NumberOfSegments
	}
	return 0
}

func (m *DeviceMultipartSettingsMessage) GetSegmentIndex() int32 {
	if m != nil {
		return m.SegmentIndex
	}
	return 0
}

type DeviceSettingsResponseMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceSettingsResponseMessage) Reset()         { *m = DeviceSettingsResponseMessage{} }
func (m *DeviceSettingsResponseMessage) String() string { return proto.CompactTextString(m) }
func (*DeviceSettingsResponseMessage) ProtoMessage()    {}
func (*DeviceSettingsResponseMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{8}
}
func (m *DeviceSettingsResponseMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceSettingsResponseMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceSettingsResponseMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceSettingsResponseMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceSettingsResponseMessage.Merge(m, src)
}
func (m *DeviceSettingsResponseMessage) XXX_Size() int {
	return m.Size()
}
func (m *DeviceSettingsResponseMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceSettingsResponseMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceSettingsResponseMessage proto.InternalMessageInfo

func (m *DeviceSettingsResponseMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *DeviceSettingsResponseMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *DeviceSettingsResponseMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

type GeneralResponseMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	Code                 int32    `protobuf:"varint,4,opt,name=code,proto3" json:"code,omitempty"`
	DataLength           int32    `protobuf:"varint,5,opt,name=dataLength,proto3" json:"dataLength,omitempty"`
	Data                 []byte   `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GeneralResponseMessage) Reset()         { *m = GeneralResponseMessage{} }
func (m *GeneralResponseMessage) String() string { return proto.CompactTextString(m) }
func (*GeneralResponseMessage) ProtoMessage()    {}
func (*GeneralResponseMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{9}
}
func (m *GeneralResponseMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GeneralResponseMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GeneralResponseMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GeneralResponseMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GeneralResponseMessage.Merge(m, src)
}
func (m *GeneralResponseMessage) XXX_Size() int {
	return m.Size()
}
func (m *GeneralResponseMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_GeneralResponseMessage.DiscardUnknown(m)
}

var xxx_messageInfo_GeneralResponseMessage proto.InternalMessageInfo

func (m *GeneralResponseMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *GeneralResponseMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *GeneralResponseMessage) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

func (m *GeneralResponseMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *GeneralResponseMessage) GetDataLength() int32 {
	if m != nil {
		return m.DataLength
	}
	return 0
}

func (m *GeneralResponseMessage) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type PullSettingsMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PullSettingsMessage) Reset()         { *m = PullSettingsMessage{} }
func (m *PullSettingsMessage) String() string { return proto.CompactTextString(m) }
func (*PullSettingsMessage) ProtoMessage()    {}
func (*PullSettingsMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{10}
}
func (m *PullSettingsMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PullSettingsMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PullSettingsMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PullSettingsMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PullSettingsMessage.Merge(m, src)
}
func (m *PullSettingsMessage) XXX_Size() int {
	return m.Size()
}
func (m *PullSettingsMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_PullSettingsMessage.DiscardUnknown(m)
}

var xxx_messageInfo_PullSettingsMessage proto.InternalMessageInfo

func (m *PullSettingsMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *PullSettingsMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

type PullWsnSettingsMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PullWsnSettingsMessage) Reset()         { *m = PullWsnSettingsMessage{} }
func (m *PullWsnSettingsMessage) String() string { return proto.CompactTextString(m) }
func (*PullWsnSettingsMessage) ProtoMessage()    {}
func (*PullWsnSettingsMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{11}
}
func (m *PullWsnSettingsMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PullWsnSettingsMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PullWsnSettingsMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PullWsnSettingsMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PullWsnSettingsMessage.Merge(m, src)
}
func (m *PullWsnSettingsMessage) XXX_Size() int {
	return m.Size()
}
func (m *PullWsnSettingsMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_PullWsnSettingsMessage.DiscardUnknown(m)
}

var xxx_messageInfo_PullWsnSettingsMessage proto.InternalMessageInfo

func (m *PullWsnSettingsMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *PullWsnSettingsMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

type SensorDataMessage struct {
	Timestamp            int32     `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string    `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	Code                 int32     `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	SensorId             int32     `protobuf:"varint,4,opt,name=sensorId,proto3" json:"sensorId,omitempty"`
	Usec                 int32     `protobuf:"varint,5,opt,name=usec,proto3" json:"usec,omitempty"`
	Length               int32     `protobuf:"varint,6,opt,name=length,proto3" json:"length,omitempty"`
	Values               []float32 `protobuf:"fixed32,7,rep,packed,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SensorDataMessage) Reset()         { *m = SensorDataMessage{} }
func (m *SensorDataMessage) String() string { return proto.CompactTextString(m) }
func (*SensorDataMessage) ProtoMessage()    {}
func (*SensorDataMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{12}
}
func (m *SensorDataMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SensorDataMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SensorDataMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SensorDataMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SensorDataMessage.Merge(m, src)
}
func (m *SensorDataMessage) XXX_Size() int {
	return m.Size()
}
func (m *SensorDataMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_SensorDataMessage.DiscardUnknown(m)
}

var xxx_messageInfo_SensorDataMessage proto.InternalMessageInfo

func (m *SensorDataMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *SensorDataMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *SensorDataMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SensorDataMessage) GetSensorId() int32 {
	if m != nil {
		return m.SensorId
	}
	return 0
}

func (m *SensorDataMessage) GetUsec() int32 {
	if m != nil {
		return m.Usec
	}
	return 0
}

func (m *SensorDataMessage) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *SensorDataMessage) GetValues() []float32 {
	if m != nil {
		return m.Values
	}
	return nil
}

type LargeSensorDataMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	SessionId            int32    `protobuf:"varint,4,opt,name=sessionId,proto3" json:"sessionId,omitempty"`
	SegmentId            int32    `protobuf:"varint,5,opt,name=segmentId,proto3" json:"segmentId,omitempty"`
	NumSegments          int32    `protobuf:"varint,6,opt,name=numSegments,proto3" json:"numSegments,omitempty"`
	MetaLength           int32    `protobuf:"varint,7,opt,name=metaLength,proto3" json:"metaLength,omitempty"`
	DataLength           int32    `protobuf:"varint,8,opt,name=dataLength,proto3" json:"dataLength,omitempty"`
	Data                 []byte   `protobuf:"bytes,9,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LargeSensorDataMessage) Reset()         { *m = LargeSensorDataMessage{} }
func (m *LargeSensorDataMessage) String() string { return proto.CompactTextString(m) }
func (*LargeSensorDataMessage) ProtoMessage()    {}
func (*LargeSensorDataMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{13}
}
func (m *LargeSensorDataMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LargeSensorDataMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LargeSensorDataMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LargeSensorDataMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LargeSensorDataMessage.Merge(m, src)
}
func (m *LargeSensorDataMessage) XXX_Size() int {
	return m.Size()
}
func (m *LargeSensorDataMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_LargeSensorDataMessage.DiscardUnknown(m)
}

var xxx_messageInfo_LargeSensorDataMessage proto.InternalMessageInfo

func (m *LargeSensorDataMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *LargeSensorDataMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *LargeSensorDataMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *LargeSensorDataMessage) GetSessionId() int32 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *LargeSensorDataMessage) GetSegmentId() int32 {
	if m != nil {
		return m.SegmentId
	}
	return 0
}

func (m *LargeSensorDataMessage) GetNumSegments() int32 {
	if m != nil {
		return m.NumSegments
	}
	return 0
}

func (m *LargeSensorDataMessage) GetMetaLength() int32 {
	if m != nil {
		return m.MetaLength
	}
	return 0
}

func (m *LargeSensorDataMessage) GetDataLength() int32 {
	if m != nil {
		return m.DataLength
	}
	return 0
}

func (m *LargeSensorDataMessage) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type ContinuousDataMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	SensorId             int32    `protobuf:"varint,4,opt,name=sensorId,proto3" json:"sensorId,omitempty"`
	Usec                 int32    `protobuf:"varint,5,opt,name=usec,proto3" json:"usec,omitempty"`
	DataLength           int32    `protobuf:"varint,6,opt,name=dataLength,proto3" json:"dataLength,omitempty"`
	Data                 []byte   `protobuf:"bytes,7,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContinuousDataMessage) Reset()         { *m = ContinuousDataMessage{} }
func (m *ContinuousDataMessage) String() string { return proto.CompactTextString(m) }
func (*ContinuousDataMessage) ProtoMessage()    {}
func (*ContinuousDataMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{14}
}
func (m *ContinuousDataMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContinuousDataMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContinuousDataMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContinuousDataMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContinuousDataMessage.Merge(m, src)
}
func (m *ContinuousDataMessage) XXX_Size() int {
	return m.Size()
}
func (m *ContinuousDataMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_ContinuousDataMessage.DiscardUnknown(m)
}

var xxx_messageInfo_ContinuousDataMessage proto.InternalMessageInfo

func (m *ContinuousDataMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ContinuousDataMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *ContinuousDataMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *ContinuousDataMessage) GetSensorId() int32 {
	if m != nil {
		return m.SensorId
	}
	return 0
}

func (m *ContinuousDataMessage) GetUsec() int32 {
	if m != nil {
		return m.Usec
	}
	return 0
}

func (m *ContinuousDataMessage) GetDataLength() int32 {
	if m != nil {
		return m.DataLength
	}
	return 0
}

func (m *ContinuousDataMessage) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type CalibrateStatusMessage struct {
	Timestamp            int32     `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string    `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	Code                 int32     `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	Step                 int32     `protobuf:"varint,4,opt,name=step,proto3" json:"step,omitempty"`
	Length               int32     `protobuf:"varint,5,opt,name=length,proto3" json:"length,omitempty"`
	Values               []float32 `protobuf:"fixed32,6,rep,packed,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CalibrateStatusMessage) Reset()         { *m = CalibrateStatusMessage{} }
func (m *CalibrateStatusMessage) String() string { return proto.CompactTextString(m) }
func (*CalibrateStatusMessage) ProtoMessage()    {}
func (*CalibrateStatusMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{15}
}
func (m *CalibrateStatusMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CalibrateStatusMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CalibrateStatusMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CalibrateStatusMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CalibrateStatusMessage.Merge(m, src)
}
func (m *CalibrateStatusMessage) XXX_Size() int {
	return m.Size()
}
func (m *CalibrateStatusMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_CalibrateStatusMessage.DiscardUnknown(m)
}

var xxx_messageInfo_CalibrateStatusMessage proto.InternalMessageInfo

func (m *CalibrateStatusMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *CalibrateStatusMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *CalibrateStatusMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *CalibrateStatusMessage) GetStep() int32 {
	if m != nil {
		return m.Step
	}
	return 0
}

func (m *CalibrateStatusMessage) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *CalibrateStatusMessage) GetValues() []float32 {
	if m != nil {
		return m.Values
	}
	return nil
}

type FirmwareUpgradeResponseMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	TaskId               string   `protobuf:"bytes,4,opt,name=taskId,proto3" json:"taskId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FirmwareUpgradeResponseMessage) Reset()         { *m = FirmwareUpgradeResponseMessage{} }
func (m *FirmwareUpgradeResponseMessage) String() string { return proto.CompactTextString(m) }
func (*FirmwareUpgradeResponseMessage) ProtoMessage()    {}
func (*FirmwareUpgradeResponseMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{16}
}
func (m *FirmwareUpgradeResponseMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirmwareUpgradeResponseMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirmwareUpgradeResponseMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FirmwareUpgradeResponseMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirmwareUpgradeResponseMessage.Merge(m, src)
}
func (m *FirmwareUpgradeResponseMessage) XXX_Size() int {
	return m.Size()
}
func (m *FirmwareUpgradeResponseMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_FirmwareUpgradeResponseMessage.DiscardUnknown(m)
}

var xxx_messageInfo_FirmwareUpgradeResponseMessage proto.InternalMessageInfo

func (m *FirmwareUpgradeResponseMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *FirmwareUpgradeResponseMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *FirmwareUpgradeResponseMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *FirmwareUpgradeResponseMessage) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

type FirmwareCancelResponseMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	TaskId               string   `protobuf:"bytes,4,opt,name=taskId,proto3" json:"taskId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FirmwareCancelResponseMessage) Reset()         { *m = FirmwareCancelResponseMessage{} }
func (m *FirmwareCancelResponseMessage) String() string { return proto.CompactTextString(m) }
func (*FirmwareCancelResponseMessage) ProtoMessage()    {}
func (*FirmwareCancelResponseMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{17}
}
func (m *FirmwareCancelResponseMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirmwareCancelResponseMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirmwareCancelResponseMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FirmwareCancelResponseMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirmwareCancelResponseMessage.Merge(m, src)
}
func (m *FirmwareCancelResponseMessage) XXX_Size() int {
	return m.Size()
}
func (m *FirmwareCancelResponseMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_FirmwareCancelResponseMessage.DiscardUnknown(m)
}

var xxx_messageInfo_FirmwareCancelResponseMessage proto.InternalMessageInfo

func (m *FirmwareCancelResponseMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *FirmwareCancelResponseMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *FirmwareCancelResponseMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *FirmwareCancelResponseMessage) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

type FirmwareLoadStatusMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	TaskId               string   `protobuf:"bytes,4,opt,name=taskId,proto3" json:"taskId,omitempty"`
	SeqId                int32    `protobuf:"varint,5,opt,name=seqId,proto3" json:"seqId,omitempty"`
	Progress             float32  `protobuf:"fixed32,6,opt,name=progress,proto3" json:"progress,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FirmwareLoadStatusMessage) Reset()         { *m = FirmwareLoadStatusMessage{} }
func (m *FirmwareLoadStatusMessage) String() string { return proto.CompactTextString(m) }
func (*FirmwareLoadStatusMessage) ProtoMessage()    {}
func (*FirmwareLoadStatusMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{18}
}
func (m *FirmwareLoadStatusMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirmwareLoadStatusMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirmwareLoadStatusMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FirmwareLoadStatusMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirmwareLoadStatusMessage.Merge(m, src)
}
func (m *FirmwareLoadStatusMessage) XXX_Size() int {
	return m.Size()
}
func (m *FirmwareLoadStatusMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_FirmwareLoadStatusMessage.DiscardUnknown(m)
}

var xxx_messageInfo_FirmwareLoadStatusMessage proto.InternalMessageInfo

func (m *FirmwareLoadStatusMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *FirmwareLoadStatusMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *FirmwareLoadStatusMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *FirmwareLoadStatusMessage) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *FirmwareLoadStatusMessage) GetSeqId() int32 {
	if m != nil {
		return m.SeqId
	}
	return 0
}

func (m *FirmwareLoadStatusMessage) GetProgress() float32 {
	if m != nil {
		return m.Progress
	}
	return 0
}

type FirmwareUpgradeStatusMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	TaskId               string   `protobuf:"bytes,4,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Progress             float32  `protobuf:"fixed32,5,opt,name=progress,proto3" json:"progress,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FirmwareUpgradeStatusMessage) Reset()         { *m = FirmwareUpgradeStatusMessage{} }
func (m *FirmwareUpgradeStatusMessage) String() string { return proto.CompactTextString(m) }
func (*FirmwareUpgradeStatusMessage) ProtoMessage()    {}
func (*FirmwareUpgradeStatusMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{19}
}
func (m *FirmwareUpgradeStatusMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FirmwareUpgradeStatusMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FirmwareUpgradeStatusMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FirmwareUpgradeStatusMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FirmwareUpgradeStatusMessage.Merge(m, src)
}
func (m *FirmwareUpgradeStatusMessage) XXX_Size() int {
	return m.Size()
}
func (m *FirmwareUpgradeStatusMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_FirmwareUpgradeStatusMessage.DiscardUnknown(m)
}

var xxx_messageInfo_FirmwareUpgradeStatusMessage proto.InternalMessageInfo

func (m *FirmwareUpgradeStatusMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *FirmwareUpgradeStatusMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *FirmwareUpgradeStatusMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *FirmwareUpgradeStatusMessage) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *FirmwareUpgradeStatusMessage) GetProgress() float32 {
	if m != nil {
		return m.Progress
	}
	return 0
}

type DeviceStatusMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	Status               string   `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceStatusMessage) Reset()         { *m = DeviceStatusMessage{} }
func (m *DeviceStatusMessage) String() string { return proto.CompactTextString(m) }
func (*DeviceStatusMessage) ProtoMessage()    {}
func (*DeviceStatusMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{20}
}
func (m *DeviceStatusMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceStatusMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceStatusMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceStatusMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceStatusMessage.Merge(m, src)
}
func (m *DeviceStatusMessage) XXX_Size() int {
	return m.Size()
}
func (m *DeviceStatusMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceStatusMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceStatusMessage proto.InternalMessageInfo

func (m *DeviceStatusMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *DeviceStatusMessage) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *DeviceStatusMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *DeviceStatusMessage) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

type TunnelDataMessage struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Code                 int32    `protobuf:"varint,3,opt,name=code,proto3" json:"code,omitempty"`
	Message              string   `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TunnelDataMessage) Reset()         { *m = TunnelDataMessage{} }
func (m *TunnelDataMessage) String() string { return proto.CompactTextString(m) }
func (*TunnelDataMessage) ProtoMessage()    {}
func (*TunnelDataMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{21}
}
func (m *TunnelDataMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelDataMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TunnelDataMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TunnelDataMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelDataMessage.Merge(m, src)
}
func (m *TunnelDataMessage) XXX_Size() int {
	return m.Size()
}
func (m *TunnelDataMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelDataMessage.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelDataMessage proto.InternalMessageInfo

func (m *TunnelDataMessage) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *TunnelDataMessage) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *TunnelDataMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type RebootCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RebootCommand) Reset()         { *m = RebootCommand{} }
func (m *RebootCommand) String() string { return proto.CompactTextString(m) }
func (*RebootCommand) ProtoMessage()    {}
func (*RebootCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{22}
}
func (m *RebootCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RebootCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RebootCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RebootCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RebootCommand.Merge(m, src)
}
func (m *RebootCommand) XXX_Size() int {
	return m.Size()
}
func (m *RebootCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_RebootCommand.DiscardUnknown(m)
}

var xxx_messageInfo_RebootCommand proto.InternalMessageInfo

func (m *RebootCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *RebootCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *RebootCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

type ResetCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResetCommand) Reset()         { *m = ResetCommand{} }
func (m *ResetCommand) String() string { return proto.CompactTextString(m) }
func (*ResetCommand) ProtoMessage()    {}
func (*ResetCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{23}
}
func (m *ResetCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResetCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResetCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetCommand.Merge(m, src)
}
func (m *ResetCommand) XXX_Size() int {
	return m.Size()
}
func (m *ResetCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetCommand.DiscardUnknown(m)
}

var xxx_messageInfo_ResetCommand proto.InternalMessageInfo

func (m *ResetCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ResetCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *ResetCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

type GetDeviceInformationCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetDeviceInformationCommand) Reset()         { *m = GetDeviceInformationCommand{} }
func (m *GetDeviceInformationCommand) String() string { return proto.CompactTextString(m) }
func (*GetDeviceInformationCommand) ProtoMessage()    {}
func (*GetDeviceInformationCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{24}
}
func (m *GetDeviceInformationCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDeviceInformationCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDeviceInformationCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDeviceInformationCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDeviceInformationCommand.Merge(m, src)
}
func (m *GetDeviceInformationCommand) XXX_Size() int {
	return m.Size()
}
func (m *GetDeviceInformationCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDeviceInformationCommand.DiscardUnknown(m)
}

var xxx_messageInfo_GetDeviceInformationCommand proto.InternalMessageInfo

func (m *GetDeviceInformationCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *GetDeviceInformationCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *GetDeviceInformationCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

type GetDeviceStatusCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetDeviceStatusCommand) Reset()         { *m = GetDeviceStatusCommand{} }
func (m *GetDeviceStatusCommand) String() string { return proto.CompactTextString(m) }
func (*GetDeviceStatusCommand) ProtoMessage()    {}
func (*GetDeviceStatusCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{25}
}
func (m *GetDeviceStatusCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDeviceStatusCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDeviceStatusCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDeviceStatusCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDeviceStatusCommand.Merge(m, src)
}
func (m *GetDeviceStatusCommand) XXX_Size() int {
	return m.Size()
}
func (m *GetDeviceStatusCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDeviceStatusCommand.DiscardUnknown(m)
}

var xxx_messageInfo_GetDeviceStatusCommand proto.InternalMessageInfo

func (m *GetDeviceStatusCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *GetDeviceStatusCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *GetDeviceStatusCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

type GetDeviceSettingsCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetDeviceSettingsCommand) Reset()         { *m = GetDeviceSettingsCommand{} }
func (m *GetDeviceSettingsCommand) String() string { return proto.CompactTextString(m) }
func (*GetDeviceSettingsCommand) ProtoMessage()    {}
func (*GetDeviceSettingsCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{26}
}
func (m *GetDeviceSettingsCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDeviceSettingsCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDeviceSettingsCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDeviceSettingsCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDeviceSettingsCommand.Merge(m, src)
}
func (m *GetDeviceSettingsCommand) XXX_Size() int {
	return m.Size()
}
func (m *GetDeviceSettingsCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDeviceSettingsCommand.DiscardUnknown(m)
}

var xxx_messageInfo_GetDeviceSettingsCommand proto.InternalMessageInfo

func (m *GetDeviceSettingsCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *GetDeviceSettingsCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *GetDeviceSettingsCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

type GetLinkStatusCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLinkStatusCommand) Reset()         { *m = GetLinkStatusCommand{} }
func (m *GetLinkStatusCommand) String() string { return proto.CompactTextString(m) }
func (*GetLinkStatusCommand) ProtoMessage()    {}
func (*GetLinkStatusCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{27}
}
func (m *GetLinkStatusCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLinkStatusCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLinkStatusCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLinkStatusCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLinkStatusCommand.Merge(m, src)
}
func (m *GetLinkStatusCommand) XXX_Size() int {
	return m.Size()
}
func (m *GetLinkStatusCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLinkStatusCommand.DiscardUnknown(m)
}

var xxx_messageInfo_GetLinkStatusCommand proto.InternalMessageInfo

func (m *GetLinkStatusCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *GetLinkStatusCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *GetLinkStatusCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

type GetLinkStatesCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLinkStatesCommand) Reset()         { *m = GetLinkStatesCommand{} }
func (m *GetLinkStatesCommand) String() string { return proto.CompactTextString(m) }
func (*GetLinkStatesCommand) ProtoMessage()    {}
func (*GetLinkStatesCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{28}
}
func (m *GetLinkStatesCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLinkStatesCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLinkStatesCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLinkStatesCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLinkStatesCommand.Merge(m, src)
}
func (m *GetLinkStatesCommand) XXX_Size() int {
	return m.Size()
}
func (m *GetLinkStatesCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLinkStatesCommand.DiscardUnknown(m)
}

var xxx_messageInfo_GetLinkStatesCommand proto.InternalMessageInfo

func (m *GetLinkStatesCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *GetLinkStatesCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *GetLinkStatesCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

type UpdateDeviceSettingsCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	Settings             string   `protobuf:"bytes,4,opt,name=settings,proto3" json:"settings,omitempty"`
	LastUpdateTime       int32    `protobuf:"varint,5,opt,name=lastUpdateTime,proto3" json:"lastUpdateTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateDeviceSettingsCommand) Reset()         { *m = UpdateDeviceSettingsCommand{} }
func (m *UpdateDeviceSettingsCommand) String() string { return proto.CompactTextString(m) }
func (*UpdateDeviceSettingsCommand) ProtoMessage()    {}
func (*UpdateDeviceSettingsCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{29}
}
func (m *UpdateDeviceSettingsCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateDeviceSettingsCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateDeviceSettingsCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateDeviceSettingsCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateDeviceSettingsCommand.Merge(m, src)
}
func (m *UpdateDeviceSettingsCommand) XXX_Size() int {
	return m.Size()
}
func (m *UpdateDeviceSettingsCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateDeviceSettingsCommand.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateDeviceSettingsCommand proto.InternalMessageInfo

func (m *UpdateDeviceSettingsCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *UpdateDeviceSettingsCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *UpdateDeviceSettingsCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

func (m *UpdateDeviceSettingsCommand) GetSettings() string {
	if m != nil {
		return m.Settings
	}
	return ""
}

func (m *UpdateDeviceSettingsCommand) GetLastUpdateTime() int32 {
	if m != nil {
		return m.LastUpdateTime
	}
	return 0
}

type UpdateWsnCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	Settings             string   `protobuf:"bytes,4,opt,name=settings,proto3" json:"settings,omitempty"`
	LastUpdateTime       int32    `protobuf:"varint,5,opt,name=lastUpdateTime,proto3" json:"lastUpdateTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateWsnCommand) Reset()         { *m = UpdateWsnCommand{} }
func (m *UpdateWsnCommand) String() string { return proto.CompactTextString(m) }
func (*UpdateWsnCommand) ProtoMessage()    {}
func (*UpdateWsnCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{30}
}
func (m *UpdateWsnCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateWsnCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateWsnCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateWsnCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateWsnCommand.Merge(m, src)
}
func (m *UpdateWsnCommand) XXX_Size() int {
	return m.Size()
}
func (m *UpdateWsnCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateWsnCommand.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateWsnCommand proto.InternalMessageInfo

func (m *UpdateWsnCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *UpdateWsnCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *UpdateWsnCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

func (m *UpdateWsnCommand) GetSettings() string {
	if m != nil {
		return m.Settings
	}
	return ""
}

func (m *UpdateWsnCommand) GetLastUpdateTime() int32 {
	if m != nil {
		return m.LastUpdateTime
	}
	return 0
}

type DeviceItem struct {
	Mac                  []byte   `protobuf:"bytes,1,opt,name=mac,proto3" json:"mac,omitempty"`
	ParentMac            []byte   `protobuf:"bytes,2,opt,name=parentMac,proto3" json:"parentMac,omitempty"`
	Name                 []byte   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Type                 int32    `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
	ModbusId             int32    `protobuf:"varint,5,opt,name=modbusId,proto3" json:"modbusId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceItem) Reset()         { *m = DeviceItem{} }
func (m *DeviceItem) String() string { return proto.CompactTextString(m) }
func (*DeviceItem) ProtoMessage()    {}
func (*DeviceItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{31}
}
func (m *DeviceItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceItem.Merge(m, src)
}
func (m *DeviceItem) XXX_Size() int {
	return m.Size()
}
func (m *DeviceItem) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceItem.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceItem proto.InternalMessageInfo

func (m *DeviceItem) GetMac() []byte {
	if m != nil {
		return m.Mac
	}
	return nil
}

func (m *DeviceItem) GetParentMac() []byte {
	if m != nil {
		return m.ParentMac
	}
	return nil
}

func (m *DeviceItem) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *DeviceItem) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *DeviceItem) GetModbusId() int32 {
	if m != nil {
		return m.ModbusId
	}
	return 0
}

type UpdateDevicesCommand struct {
	Timestamp            int32         `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string        `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32         `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	Items                []*DeviceItem `protobuf:"bytes,10,rep,name=items,proto3" json:"items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UpdateDevicesCommand) Reset()         { *m = UpdateDevicesCommand{} }
func (m *UpdateDevicesCommand) String() string { return proto.CompactTextString(m) }
func (*UpdateDevicesCommand) ProtoMessage()    {}
func (*UpdateDevicesCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{32}
}
func (m *UpdateDevicesCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateDevicesCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateDevicesCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateDevicesCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateDevicesCommand.Merge(m, src)
}
func (m *UpdateDevicesCommand) XXX_Size() int {
	return m.Size()
}
func (m *UpdateDevicesCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateDevicesCommand.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateDevicesCommand proto.InternalMessageInfo

func (m *UpdateDevicesCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *UpdateDevicesCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *UpdateDevicesCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

func (m *UpdateDevicesCommand) GetItems() []*DeviceItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type AddDeviceCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	Mac                  []byte   `protobuf:"bytes,4,opt,name=mac,proto3" json:"mac,omitempty"`
	ParentMac            []byte   `protobuf:"bytes,5,opt,name=parentMac,proto3" json:"parentMac,omitempty"`
	Name                 []byte   `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	Type                 int32    `protobuf:"varint,7,opt,name=type,proto3" json:"type,omitempty"`
	ModbusId             int32    `protobuf:"varint,8,opt,name=modbusId,proto3" json:"modbusId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddDeviceCommand) Reset()         { *m = AddDeviceCommand{} }
func (m *AddDeviceCommand) String() string { return proto.CompactTextString(m) }
func (*AddDeviceCommand) ProtoMessage()    {}
func (*AddDeviceCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{33}
}
func (m *AddDeviceCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddDeviceCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddDeviceCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddDeviceCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddDeviceCommand.Merge(m, src)
}
func (m *AddDeviceCommand) XXX_Size() int {
	return m.Size()
}
func (m *AddDeviceCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_AddDeviceCommand.DiscardUnknown(m)
}

var xxx_messageInfo_AddDeviceCommand proto.InternalMessageInfo

func (m *AddDeviceCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *AddDeviceCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *AddDeviceCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

func (m *AddDeviceCommand) GetMac() []byte {
	if m != nil {
		return m.Mac
	}
	return nil
}

func (m *AddDeviceCommand) GetParentMac() []byte {
	if m != nil {
		return m.ParentMac
	}
	return nil
}

func (m *AddDeviceCommand) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *AddDeviceCommand) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *AddDeviceCommand) GetModbusId() int32 {
	if m != nil {
		return m.ModbusId
	}
	return 0
}

type UpdateDeviceCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	Mac                  []byte   `protobuf:"bytes,4,opt,name=mac,proto3" json:"mac,omitempty"`
	ParentMac            []byte   `protobuf:"bytes,5,opt,name=parentMac,proto3" json:"parentMac,omitempty"`
	Name                 []byte   `protobuf:"bytes,6,opt,name=name,proto3" json:"name,omitempty"`
	Type                 int32    `protobuf:"varint,7,opt,name=type,proto3" json:"type,omitempty"`
	ModbusId             int32    `protobuf:"varint,8,opt,name=modbusId,proto3" json:"modbusId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateDeviceCommand) Reset()         { *m = UpdateDeviceCommand{} }
func (m *UpdateDeviceCommand) String() string { return proto.CompactTextString(m) }
func (*UpdateDeviceCommand) ProtoMessage()    {}
func (*UpdateDeviceCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{34}
}
func (m *UpdateDeviceCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateDeviceCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateDeviceCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateDeviceCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateDeviceCommand.Merge(m, src)
}
func (m *UpdateDeviceCommand) XXX_Size() int {
	return m.Size()
}
func (m *UpdateDeviceCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateDeviceCommand.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateDeviceCommand proto.InternalMessageInfo

func (m *UpdateDeviceCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *UpdateDeviceCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *UpdateDeviceCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

func (m *UpdateDeviceCommand) GetMac() []byte {
	if m != nil {
		return m.Mac
	}
	return nil
}

func (m *UpdateDeviceCommand) GetParentMac() []byte {
	if m != nil {
		return m.ParentMac
	}
	return nil
}

func (m *UpdateDeviceCommand) GetName() []byte {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *UpdateDeviceCommand) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *UpdateDeviceCommand) GetModbusId() int32 {
	if m != nil {
		return m.ModbusId
	}
	return 0
}

type DeleteDeviceCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	Mac                  []byte   `protobuf:"bytes,4,opt,name=mac,proto3" json:"mac,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteDeviceCommand) Reset()         { *m = DeleteDeviceCommand{} }
func (m *DeleteDeviceCommand) String() string { return proto.CompactTextString(m) }
func (*DeleteDeviceCommand) ProtoMessage()    {}
func (*DeleteDeviceCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{35}
}
func (m *DeleteDeviceCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteDeviceCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteDeviceCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteDeviceCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteDeviceCommand.Merge(m, src)
}
func (m *DeleteDeviceCommand) XXX_Size() int {
	return m.Size()
}
func (m *DeleteDeviceCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteDeviceCommand.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteDeviceCommand proto.InternalMessageInfo

func (m *DeleteDeviceCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *DeleteDeviceCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *DeleteDeviceCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

func (m *DeleteDeviceCommand) GetMac() []byte {
	if m != nil {
		return m.Mac
	}
	return nil
}

type ClearDevicesCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClearDevicesCommand) Reset()         { *m = ClearDevicesCommand{} }
func (m *ClearDevicesCommand) String() string { return proto.CompactTextString(m) }
func (*ClearDevicesCommand) ProtoMessage()    {}
func (*ClearDevicesCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{36}
}
func (m *ClearDevicesCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearDevicesCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearDevicesCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearDevicesCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearDevicesCommand.Merge(m, src)
}
func (m *ClearDevicesCommand) XXX_Size() int {
	return m.Size()
}
func (m *ClearDevicesCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearDevicesCommand.DiscardUnknown(m)
}

var xxx_messageInfo_ClearDevicesCommand proto.InternalMessageInfo

func (m *ClearDevicesCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ClearDevicesCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *ClearDevicesCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

type SetTimeCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SetTimeCommand) Reset()         { *m = SetTimeCommand{} }
func (m *SetTimeCommand) String() string { return proto.CompactTextString(m) }
func (*SetTimeCommand) ProtoMessage()    {}
func (*SetTimeCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{37}
}
func (m *SetTimeCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetTimeCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetTimeCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetTimeCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetTimeCommand.Merge(m, src)
}
func (m *SetTimeCommand) XXX_Size() int {
	return m.Size()
}
func (m *SetTimeCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_SetTimeCommand.DiscardUnknown(m)
}

var xxx_messageInfo_SetTimeCommand proto.InternalMessageInfo

func (m *SetTimeCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *SetTimeCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *SetTimeCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

type MaintainCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MaintainCommand) Reset()         { *m = MaintainCommand{} }
func (m *MaintainCommand) String() string { return proto.CompactTextString(m) }
func (*MaintainCommand) ProtoMessage()    {}
func (*MaintainCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{38}
}
func (m *MaintainCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MaintainCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MaintainCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MaintainCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MaintainCommand.Merge(m, src)
}
func (m *MaintainCommand) XXX_Size() int {
	return m.Size()
}
func (m *MaintainCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_MaintainCommand.DiscardUnknown(m)
}

var xxx_messageInfo_MaintainCommand proto.InternalMessageInfo

func (m *MaintainCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *MaintainCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *MaintainCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

type ProvisionCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProvisionCommand) Reset()         { *m = ProvisionCommand{} }
func (m *ProvisionCommand) String() string { return proto.CompactTextString(m) }
func (*ProvisionCommand) ProtoMessage()    {}
func (*ProvisionCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{39}
}
func (m *ProvisionCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProvisionCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProvisionCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProvisionCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProvisionCommand.Merge(m, src)
}
func (m *ProvisionCommand) XXX_Size() int {
	return m.Size()
}
func (m *ProvisionCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_ProvisionCommand.DiscardUnknown(m)
}

var xxx_messageInfo_ProvisionCommand proto.InternalMessageInfo

func (m *ProvisionCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ProvisionCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *ProvisionCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

type CalibrateCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	Type                 int32    `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
	Param1               float32  `protobuf:"fixed32,5,opt,name=param1,proto3" json:"param1,omitempty"`
	Param2               float32  `protobuf:"fixed32,6,opt,name=param2,proto3" json:"param2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CalibrateCommand) Reset()         { *m = CalibrateCommand{} }
func (m *CalibrateCommand) String() string { return proto.CompactTextString(m) }
func (*CalibrateCommand) ProtoMessage()    {}
func (*CalibrateCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{40}
}
func (m *CalibrateCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CalibrateCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CalibrateCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CalibrateCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CalibrateCommand.Merge(m, src)
}
func (m *CalibrateCommand) XXX_Size() int {
	return m.Size()
}
func (m *CalibrateCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_CalibrateCommand.DiscardUnknown(m)
}

var xxx_messageInfo_CalibrateCommand proto.InternalMessageInfo

func (m *CalibrateCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *CalibrateCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *CalibrateCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

func (m *CalibrateCommand) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *CalibrateCommand) GetParam1() float32 {
	if m != nil {
		return m.Param1
	}
	return 0
}

func (m *CalibrateCommand) GetParam2() float32 {
	if m != nil {
		return m.Param2
	}
	return 0
}

type ResetDataCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	Type                 int32    `protobuf:"varint,4,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResetDataCommand) Reset()         { *m = ResetDataCommand{} }
func (m *ResetDataCommand) String() string { return proto.CompactTextString(m) }
func (*ResetDataCommand) ProtoMessage()    {}
func (*ResetDataCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{41}
}
func (m *ResetDataCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResetDataCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResetDataCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResetDataCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResetDataCommand.Merge(m, src)
}
func (m *ResetDataCommand) XXX_Size() int {
	return m.Size()
}
func (m *ResetDataCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_ResetDataCommand.DiscardUnknown(m)
}

var xxx_messageInfo_ResetDataCommand proto.InternalMessageInfo

func (m *ResetDataCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *ResetDataCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *ResetDataCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

func (m *ResetDataCommand) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

type InspectCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectCommand) Reset()         { *m = InspectCommand{} }
func (m *InspectCommand) String() string { return proto.CompactTextString(m) }
func (*InspectCommand) ProtoMessage()    {}
func (*InspectCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{42}
}
func (m *InspectCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectCommand.Merge(m, src)
}
func (m *InspectCommand) XXX_Size() int {
	return m.Size()
}
func (m *InspectCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectCommand.DiscardUnknown(m)
}

var xxx_messageInfo_InspectCommand proto.InternalMessageInfo

func (m *InspectCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *InspectCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *InspectCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

type UpgradeFirmwareCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	TaskId               string   `protobuf:"bytes,4,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Model                string   `protobuf:"bytes,5,opt,name=model,proto3" json:"model,omitempty"`
	Crc                  string   `protobuf:"bytes,6,opt,name=crc,proto3" json:"crc,omitempty"`
	Major                int32    `protobuf:"varint,7,opt,name=major,proto3" json:"major,omitempty"`
	Minor                int32    `protobuf:"varint,8,opt,name=minor,proto3" json:"minor,omitempty"`
	Version              int32    `protobuf:"varint,9,opt,name=version,proto3" json:"version,omitempty"`
	Size_                int32    `protobuf:"varint,10,opt,name=size,proto3" json:"size,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpgradeFirmwareCommand) Reset()         { *m = UpgradeFirmwareCommand{} }
func (m *UpgradeFirmwareCommand) String() string { return proto.CompactTextString(m) }
func (*UpgradeFirmwareCommand) ProtoMessage()    {}
func (*UpgradeFirmwareCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{43}
}
func (m *UpgradeFirmwareCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpgradeFirmwareCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpgradeFirmwareCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpgradeFirmwareCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpgradeFirmwareCommand.Merge(m, src)
}
func (m *UpgradeFirmwareCommand) XXX_Size() int {
	return m.Size()
}
func (m *UpgradeFirmwareCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_UpgradeFirmwareCommand.DiscardUnknown(m)
}

var xxx_messageInfo_UpgradeFirmwareCommand proto.InternalMessageInfo

func (m *UpgradeFirmwareCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *UpgradeFirmwareCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *UpgradeFirmwareCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

func (m *UpgradeFirmwareCommand) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *UpgradeFirmwareCommand) GetModel() string {
	if m != nil {
		return m.Model
	}
	return ""
}

func (m *UpgradeFirmwareCommand) GetCrc() string {
	if m != nil {
		return m.Crc
	}
	return ""
}

func (m *UpgradeFirmwareCommand) GetMajor() int32 {
	if m != nil {
		return m.Major
	}
	return 0
}

func (m *UpgradeFirmwareCommand) GetMinor() int32 {
	if m != nil {
		return m.Minor
	}
	return 0
}

func (m *UpgradeFirmwareCommand) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *UpgradeFirmwareCommand) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

type CancelFirmwareCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	TaskId               string   `protobuf:"bytes,4,opt,name=taskId,proto3" json:"taskId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CancelFirmwareCommand) Reset()         { *m = CancelFirmwareCommand{} }
func (m *CancelFirmwareCommand) String() string { return proto.CompactTextString(m) }
func (*CancelFirmwareCommand) ProtoMessage()    {}
func (*CancelFirmwareCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{44}
}
func (m *CancelFirmwareCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelFirmwareCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelFirmwareCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelFirmwareCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelFirmwareCommand.Merge(m, src)
}
func (m *CancelFirmwareCommand) XXX_Size() int {
	return m.Size()
}
func (m *CancelFirmwareCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelFirmwareCommand.DiscardUnknown(m)
}

var xxx_messageInfo_CancelFirmwareCommand proto.InternalMessageInfo

func (m *CancelFirmwareCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *CancelFirmwareCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *CancelFirmwareCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

func (m *CancelFirmwareCommand) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

type LoadFirmwareCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	TaskId               string   `protobuf:"bytes,4,opt,name=taskId,proto3" json:"taskId,omitempty"`
	Size_                int32    `protobuf:"varint,5,opt,name=size,proto3" json:"size,omitempty"`
	SeqId                int32    `protobuf:"varint,6,opt,name=seqId,proto3" json:"seqId,omitempty"`
	DataLength           int32    `protobuf:"varint,7,opt,name=dataLength,proto3" json:"dataLength,omitempty"`
	Data                 []byte   `protobuf:"bytes,8,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoadFirmwareCommand) Reset()         { *m = LoadFirmwareCommand{} }
func (m *LoadFirmwareCommand) String() string { return proto.CompactTextString(m) }
func (*LoadFirmwareCommand) ProtoMessage()    {}
func (*LoadFirmwareCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{45}
}
func (m *LoadFirmwareCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoadFirmwareCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoadFirmwareCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoadFirmwareCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoadFirmwareCommand.Merge(m, src)
}
func (m *LoadFirmwareCommand) XXX_Size() int {
	return m.Size()
}
func (m *LoadFirmwareCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_LoadFirmwareCommand.DiscardUnknown(m)
}

var xxx_messageInfo_LoadFirmwareCommand proto.InternalMessageInfo

func (m *LoadFirmwareCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *LoadFirmwareCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *LoadFirmwareCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

func (m *LoadFirmwareCommand) GetTaskId() string {
	if m != nil {
		return m.TaskId
	}
	return ""
}

func (m *LoadFirmwareCommand) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *LoadFirmwareCommand) GetSeqId() int32 {
	if m != nil {
		return m.SeqId
	}
	return 0
}

func (m *LoadFirmwareCommand) GetDataLength() int32 {
	if m != nil {
		return m.DataLength
	}
	return 0
}

func (m *LoadFirmwareCommand) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type GetSensorDataCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetSensorDataCommand) Reset()         { *m = GetSensorDataCommand{} }
func (m *GetSensorDataCommand) String() string { return proto.CompactTextString(m) }
func (*GetSensorDataCommand) ProtoMessage()    {}
func (*GetSensorDataCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{46}
}
func (m *GetSensorDataCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetSensorDataCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetSensorDataCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetSensorDataCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetSensorDataCommand.Merge(m, src)
}
func (m *GetSensorDataCommand) XXX_Size() int {
	return m.Size()
}
func (m *GetSensorDataCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_GetSensorDataCommand.DiscardUnknown(m)
}

var xxx_messageInfo_GetSensorDataCommand proto.InternalMessageInfo

func (m *GetSensorDataCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *GetSensorDataCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *GetSensorDataCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

type AcquireSensorDataCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AcquireSensorDataCommand) Reset()         { *m = AcquireSensorDataCommand{} }
func (m *AcquireSensorDataCommand) String() string { return proto.CompactTextString(m) }
func (*AcquireSensorDataCommand) ProtoMessage()    {}
func (*AcquireSensorDataCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{47}
}
func (m *AcquireSensorDataCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcquireSensorDataCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcquireSensorDataCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcquireSensorDataCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcquireSensorDataCommand.Merge(m, src)
}
func (m *AcquireSensorDataCommand) XXX_Size() int {
	return m.Size()
}
func (m *AcquireSensorDataCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_AcquireSensorDataCommand.DiscardUnknown(m)
}

var xxx_messageInfo_AcquireSensorDataCommand proto.InternalMessageInfo

func (m *AcquireSensorDataCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *AcquireSensorDataCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *AcquireSensorDataCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

type TunnelCommand struct {
	Timestamp            int32    `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	ReqId                string   `protobuf:"bytes,2,opt,name=reqId,proto3" json:"reqId,omitempty"`
	SubCommand           int32    `protobuf:"varint,3,opt,name=subCommand,proto3" json:"subCommand,omitempty"`
	Duration             int32    `protobuf:"varint,4,opt,name=duration,proto3" json:"duration,omitempty"`
	Message              string   `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TunnelCommand) Reset()         { *m = TunnelCommand{} }
func (m *TunnelCommand) String() string { return proto.CompactTextString(m) }
func (*TunnelCommand) ProtoMessage()    {}
func (*TunnelCommand) Descriptor() ([]byte, []int) {
	return fileDescriptor_2a4fa2d5dc0fd069, []int{48}
}
func (m *TunnelCommand) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TunnelCommand) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TunnelCommand.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TunnelCommand) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TunnelCommand.Merge(m, src)
}
func (m *TunnelCommand) XXX_Size() int {
	return m.Size()
}
func (m *TunnelCommand) XXX_DiscardUnknown() {
	xxx_messageInfo_TunnelCommand.DiscardUnknown(m)
}

var xxx_messageInfo_TunnelCommand proto.InternalMessageInfo

func (m *TunnelCommand) GetTimestamp() int32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *TunnelCommand) GetReqId() string {
	if m != nil {
		return m.ReqId
	}
	return ""
}

func (m *TunnelCommand) GetSubCommand() int32 {
	if m != nil {
		return m.SubCommand
	}
	return 0
}

func (m *TunnelCommand) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *TunnelCommand) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func init() {
	proto.RegisterType((*ByeMessage)(nil), "ByeMessage")
	proto.RegisterType((*LinkStatusMessage)(nil), "LinkStatusMessage")
	proto.RegisterType((*LinkStatesMessage)(nil), "LinkStatesMessage")
	proto.RegisterType((*GeneralStatusMessage)(nil), "GeneralStatusMessage")
	proto.RegisterType((*EventMessage)(nil), "EventMessage")
	proto.RegisterType((*DeviceInformationMessage)(nil), "DeviceInformationMessage")
	proto.RegisterType((*DeviceSettingsMessage)(nil), "DeviceSettingsMessage")
	proto.RegisterType((*DeviceMultipartSettingsMessage)(nil), "DeviceMultipartSettingsMessage")
	proto.RegisterType((*DeviceSettingsResponseMessage)(nil), "DeviceSettingsResponseMessage")
	proto.RegisterType((*GeneralResponseMessage)(nil), "GeneralResponseMessage")
	proto.RegisterType((*PullSettingsMessage)(nil), "PullSettingsMessage")
	proto.RegisterType((*PullWsnSettingsMessage)(nil), "PullWsnSettingsMessage")
	proto.RegisterType((*SensorDataMessage)(nil), "SensorDataMessage")
	proto.RegisterType((*LargeSensorDataMessage)(nil), "LargeSensorDataMessage")
	proto.RegisterType((*ContinuousDataMessage)(nil), "ContinuousDataMessage")
	proto.RegisterType((*CalibrateStatusMessage)(nil), "CalibrateStatusMessage")
	proto.RegisterType((*FirmwareUpgradeResponseMessage)(nil), "FirmwareUpgradeResponseMessage")
	proto.RegisterType((*FirmwareCancelResponseMessage)(nil), "FirmwareCancelResponseMessage")
	proto.RegisterType((*FirmwareLoadStatusMessage)(nil), "FirmwareLoadStatusMessage")
	proto.RegisterType((*FirmwareUpgradeStatusMessage)(nil), "FirmwareUpgradeStatusMessage")
	proto.RegisterType((*DeviceStatusMessage)(nil), "DeviceStatusMessage")
	proto.RegisterType((*TunnelDataMessage)(nil), "TunnelDataMessage")
	proto.RegisterType((*RebootCommand)(nil), "RebootCommand")
	proto.RegisterType((*ResetCommand)(nil), "ResetCommand")
	proto.RegisterType((*GetDeviceInformationCommand)(nil), "GetDeviceInformationCommand")
	proto.RegisterType((*GetDeviceStatusCommand)(nil), "GetDeviceStatusCommand")
	proto.RegisterType((*GetDeviceSettingsCommand)(nil), "GetDeviceSettingsCommand")
	proto.RegisterType((*GetLinkStatusCommand)(nil), "GetLinkStatusCommand")
	proto.RegisterType((*GetLinkStatesCommand)(nil), "GetLinkStatesCommand")
	proto.RegisterType((*UpdateDeviceSettingsCommand)(nil), "UpdateDeviceSettingsCommand")
	proto.RegisterType((*UpdateWsnCommand)(nil), "UpdateWsnCommand")
	proto.RegisterType((*DeviceItem)(nil), "DeviceItem")
	proto.RegisterType((*UpdateDevicesCommand)(nil), "UpdateDevicesCommand")
	proto.RegisterType((*AddDeviceCommand)(nil), "AddDeviceCommand")
	proto.RegisterType((*UpdateDeviceCommand)(nil), "UpdateDeviceCommand")
	proto.RegisterType((*DeleteDeviceCommand)(nil), "DeleteDeviceCommand")
	proto.RegisterType((*ClearDevicesCommand)(nil), "ClearDevicesCommand")
	proto.RegisterType((*SetTimeCommand)(nil), "SetTimeCommand")
	proto.RegisterType((*MaintainCommand)(nil), "MaintainCommand")
	proto.RegisterType((*ProvisionCommand)(nil), "ProvisionCommand")
	proto.RegisterType((*CalibrateCommand)(nil), "CalibrateCommand")
	proto.RegisterType((*ResetDataCommand)(nil), "ResetDataCommand")
	proto.RegisterType((*InspectCommand)(nil), "InspectCommand")
	proto.RegisterType((*UpgradeFirmwareCommand)(nil), "UpgradeFirmwareCommand")
	proto.RegisterType((*CancelFirmwareCommand)(nil), "CancelFirmwareCommand")
	proto.RegisterType((*LoadFirmwareCommand)(nil), "LoadFirmwareCommand")
	proto.RegisterType((*GetSensorDataCommand)(nil), "GetSensorDataCommand")
	proto.RegisterType((*AcquireSensorDataCommand)(nil), "AcquireSensorDataCommand")
	proto.RegisterType((*TunnelCommand)(nil), "TunnelCommand")
}

func init() {
	proto.RegisterFile("server/adapter/iot/proto/theta.proto", fileDescriptor_2a4fa2d5dc0fd069)
}

var fileDescriptor_2a4fa2d5dc0fd069 = []byte{
	// 1234 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x59, 0xcf, 0x8f, 0xdb, 0xc4,
	0x17, 0xd7, 0xec, 0xc6, 0xd9, 0xcd, 0x6b, 0xda, 0xef, 0x36, 0xdb, 0x46, 0xfe, 0xd2, 0x36, 0x0a,
	0x23, 0x84, 0x56, 0x1c, 0xba, 0xa2, 0xdc, 0x91, 0xda, 0x2d, 0x54, 0x91, 0xb6, 0xa2, 0xf2, 0xb6,
	0xea, 0x11, 0x4d, 0xe2, 0xd7, 0xd4, 0xad, 0x3d, 0x76, 0x67, 0xc6, 0x81, 0xb6, 0x48, 0x54, 0x02,
	0x71, 0xe3, 0xc2, 0x0d, 0xce, 0x9c, 0x90, 0xb8, 0xc1, 0x09, 0x89, 0x0b, 0x17, 0x8e, 0x1c, 0x38,
	0x21, 0x21, 0x50, 0xff, 0x12, 0x34, 0x3f, 0x62, 0x3b, 0x69, 0x52, 0x95, 0x2a, 0xce, 0x56, 0xdc,
	0xe6, 0x3d, 0x3b, 0xf3, 0xf9, 0xcc, 0xfb, 0x35, 0xef, 0x39, 0xf0, 0x86, 0x44, 0x31, 0x41, 0xb1,
	0xcf, 0x42, 0x96, 0x29, 0x14, 0xfb, 0x51, 0xaa, 0xf6, 0x33, 0x91, 0xaa, 0x74, 0x5f, 0xdd, 0x45,
	0xc5, 0x2e, 0x9a, 0x35, 0x7d, 0x17, 0xe0, 0xca, 0x43, 0xbc, 0x8e, 0x52, 0xb2, 0x31, 0x76, 0xce,
	0x43, 0x4b, 0x45, 0x09, 0x4a, 0xc5, 0x92, 0xcc, 0x27, 0x7d, 0xb2, 0xe7, 0x05, 0xa5, 0xa2, 0xd3,
	0x81, 0xc6, 0x28, 0x0d, 0xd1, 0xdf, 0x34, 0x0f, 0xcc, 0x9a, 0x4a, 0x38, 0x7d, 0x18, 0xf1, 0xfb,
	0x47, 0x8a, 0xa9, 0x5c, 0xbe, 0xd8, 0x36, 0x67, 0xc0, 0x13, 0xf8, 0x60, 0x10, 0xfa, 0x1b, 0x7d,
	0xb2, 0xd7, 0x0a, 0xac, 0xb0, 0x68, 0xf3, 0x4e, 0x17, 0x9a, 0xd2, 0x6c, 0xec, 0x37, 0xcc, 0xab,
	0x4e, 0xaa, 0x82, 0x62, 0x5d, 0xa0, 0x38, 0x03, 0x8a, 0x92, 0x7e, 0x02, 0x67, 0xae, 0x21, 0x47,
	0xc1, 0xe2, 0x7f, 0x73, 0xd8, 0x45, 0x08, 0x3d, 0x80, 0x90, 0x29, 0x76, 0x88, 0x7c, 0xac, 0xee,
	0x1a, 0x14, 0x2f, 0xa8, 0x68, 0xf4, 0x6f, 0xb4, 0xe4, 0x7b, 0x7d, 0xb2, 0xd7, 0x0e, 0xcc, 0x9a,
	0xfe, 0x4c, 0xa0, 0xfd, 0xde, 0x04, 0xb9, 0x7a, 0x79, 0xd8, 0x0e, 0x34, 0xd4, 0xc3, 0x0c, 0x1d,
	0xa0, 0x59, 0x77, 0x5e, 0x83, 0x6d, 0x89, 0x13, 0x14, 0x91, 0x7a, 0x68, 0xe0, 0xbc, 0xa0, 0x90,
	0xe7, 0x68, 0x36, 0x97, 0xd2, 0xdc, 0x2a, 0x69, 0x76, 0x7c, 0xd8, 0x4a, 0x2c, 0x41, 0x7f, 0xdb,
	0x58, 0x6f, 0x2a, 0xd2, 0xcf, 0x09, 0xf8, 0x57, 0x71, 0x12, 0x8d, 0x70, 0xc0, 0xef, 0xa4, 0x22,
	0x61, 0x2a, 0x4a, 0xf9, 0xaa, 0x7d, 0xd7, 0x87, 0x13, 0x51, 0xb9, 0xbb, 0x73, 0x60, 0x55, 0x45,
	0x1f, 0xc3, 0x59, 0xcb, 0xe2, 0x08, 0x95, 0x8a, 0xf8, 0x78, 0xe5, 0xe1, 0x63, 0x2c, 0x6a, 0xb7,
	0x76, 0xf8, 0x85, 0x4c, 0x7f, 0x27, 0xd0, 0xb3, 0xe8, 0xd7, 0xf3, 0x58, 0x45, 0x19, 0x13, 0xea,
	0x18, 0x68, 0x74, 0xde, 0x82, 0x1d, 0x9e, 0x27, 0x43, 0x14, 0x1f, 0xdc, 0x39, 0xc2, 0x71, 0x82,
	0x5c, 0x49, 0xe7, 0xfc, 0x67, 0xf4, 0x1d, 0x0a, 0x6d, 0x69, 0xd7, 0x03, 0x1e, 0xe2, 0xc7, 0x2e,
	0x0c, 0x66, 0x74, 0x74, 0x0c, 0x17, 0x66, 0x6d, 0x1a, 0xa0, 0xcc, 0x52, 0x2e, 0x71, 0xc5, 0x87,
	0xa2, 0x3f, 0x10, 0xe8, 0xba, 0x1c, 0x5c, 0x05, 0x44, 0x0f, 0x40, 0xe6, 0xc3, 0x83, 0x34, 0x49,
	0x18, 0x0f, 0x1d, 0x50, 0x45, 0x53, 0x50, 0x68, 0x2c, 0xcd, 0x5d, 0x6f, 0x69, 0x52, 0x34, 0x2b,
	0xb9, 0x3b, 0x80, 0xdd, 0x1b, 0x79, 0x1c, 0xaf, 0xc0, 0xd5, 0xf4, 0x10, 0xba, 0x7a, 0xab, 0xdb,
	0x92, 0xaf, 0x62, 0xb7, 0x9f, 0x08, 0x9c, 0x3e, 0x42, 0x2e, 0x53, 0x71, 0x95, 0x29, 0x56, 0x4b,
	0x08, 0xea, 0xcd, 0x07, 0xa1, 0x33, 0x61, 0x21, 0xeb, 0xf7, 0x73, 0x89, 0x23, 0x67, 0x40, 0xb3,
	0xd6, 0x85, 0x37, 0xae, 0xd6, 0x1a, 0x27, 0x69, 0xfd, 0x84, 0xc5, 0x39, 0x4a, 0x7f, 0xab, 0xbf,
	0xb9, 0xb7, 0x11, 0x38, 0x89, 0x7e, 0xb5, 0x01, 0xdd, 0x43, 0x26, 0xc6, 0x58, 0xdf, 0x11, 0xce,
	0x43, 0x4b, 0xa2, 0x94, 0x51, 0xca, 0x8b, 0x33, 0x94, 0x0a, 0xfb, 0xd4, 0xe6, 0x41, 0xe8, 0x4e,
	0x52, 0x2a, 0x74, 0x2d, 0xe2, 0x79, 0x52, 0x24, 0x98, 0x3d, 0x53, 0x55, 0xa5, 0x63, 0x29, 0xc1,
	0x22, 0x96, 0xb6, 0x6c, 0x2c, 0x95, 0x9a, 0xb9, 0x58, 0xdb, 0x5e, 0x1a, 0x6b, 0xad, 0x4a, 0xac,
	0xfd, 0x42, 0xe0, 0xec, 0x41, 0xca, 0x55, 0xc4, 0xf3, 0x34, 0x97, 0xaf, 0x82, 0x5b, 0x5f, 0xe2,
	0x1a, 0xa1, 0xdf, 0x12, 0xe8, 0x1e, 0xb0, 0x38, 0x1a, 0x0a, 0xa6, 0xb0, 0x9e, 0xde, 0xa2, 0x03,
	0x0d, 0xa9, 0x30, 0x9b, 0x26, 0xb7, 0x5e, 0x57, 0x22, 0xd0, 0x5b, 0x12, 0x81, 0xcd, 0x99, 0x08,
	0x7c, 0x42, 0xa0, 0xf7, 0x7e, 0x24, 0x92, 0x8f, 0x98, 0xc0, 0x5b, 0xd9, 0x58, 0xb0, 0x10, 0x6b,
	0x2a, 0x7d, 0x9a, 0x82, 0x62, 0xf2, 0xbe, 0xb3, 0x79, 0x2b, 0x70, 0x12, 0xfd, 0x14, 0x2e, 0x4c,
	0x19, 0x1c, 0x30, 0x3e, 0xc2, 0x78, 0xdd, 0x04, 0xbe, 0x27, 0xf0, 0xff, 0x29, 0x83, 0xc3, 0x94,
	0x85, 0xb5, 0x75, 0x82, 0x8b, 0xd0, 0xf5, 0x0e, 0xd2, 0xec, 0x60, 0x1d, 0x66, 0x05, 0x1d, 0xa2,
	0x99, 0x48, 0xc7, 0x02, 0xa5, 0xcd, 0xbb, 0x8d, 0xa0, 0x90, 0xe9, 0x37, 0x04, 0xce, 0xcf, 0xf9,
	0x6c, 0xbd, 0x94, 0xab, 0xe4, 0xbc, 0x39, 0x72, 0x39, 0xec, 0xba, 0x9b, 0x74, 0xad, 0xfd, 0xf4,
	0x87, 0x70, 0xfa, 0x66, 0xce, 0x39, 0xc6, 0x2f, 0x5e, 0x2f, 0x16, 0x6d, 0x5f, 0x69, 0xfe, 0x1a,
	0xb3, 0xcd, 0xdf, 0x08, 0x4e, 0x06, 0x38, 0x4c, 0x53, 0x35, 0xbd, 0x5a, 0x6b, 0xb8, 0xae, 0xe9,
	0x10, 0xda, 0x01, 0x4a, 0xac, 0x15, 0xe3, 0x01, 0x9c, 0xbb, 0x86, 0xea, 0x99, 0x3e, 0xb6, 0x4e,
	0xc8, 0x58, 0xf7, 0x3c, 0xaa, 0x1a, 0x16, 0x75, 0xa2, 0x71, 0xf0, 0x4b, 0x34, 0xd7, 0x62, 0xd4,
	0x89, 0x77, 0x4f, 0x4f, 0x55, 0xaa, 0x1c, 0x21, 0xd7, 0x87, 0x85, 0xb5, 0x62, 0xfd, 0x48, 0xe0,
	0xdc, 0xad, 0x2c, 0x64, 0x0a, 0xd7, 0x66, 0xcb, 0xe7, 0xf6, 0xfc, 0x6f, 0xc2, 0xa9, 0x98, 0x49,
	0x65, 0x29, 0xdd, 0x8c, 0x12, 0x74, 0x15, 0x73, 0x4e, 0x4b, 0xbf, 0x23, 0xb0, 0x63, 0xc5, 0xdb,
	0x92, 0xbf, 0xea, 0x64, 0x9f, 0x10, 0x00, 0x97, 0x8b, 0x0a, 0x93, 0xce, 0x0e, 0x6c, 0x26, 0x6c,
	0x64, 0x08, 0xb6, 0x03, 0xbd, 0xd4, 0xc4, 0x33, 0x26, 0xf4, 0xd4, 0xcc, 0x46, 0x86, 0x5e, 0x3b,
	0x28, 0x15, 0xba, 0x86, 0x71, 0x96, 0xd8, 0x1a, 0xd6, 0x0e, 0xcc, 0x7a, 0xd9, 0x90, 0x9c, 0xa4,
	0xe1, 0x30, 0x97, 0xc5, 0x3d, 0x53, 0xc8, 0xf4, 0x4b, 0x02, 0x67, 0xaa, 0x7e, 0xae, 0xd5, 0xc1,
	0xaf, 0x83, 0x17, 0x29, 0x4c, 0xa4, 0x0f, 0xfd, 0xcd, 0xbd, 0x13, 0x97, 0x4e, 0x5c, 0x2c, 0x0f,
	0x1f, 0xd8, 0x27, 0xf4, 0x0f, 0x02, 0x3b, 0x97, 0xc3, 0xd0, 0x3e, 0xa8, 0x93, 0x8b, 0x33, 0x76,
	0x63, 0x89, 0xb1, 0xbd, 0x65, 0xc6, 0x6e, 0x2e, 0x30, 0xf6, 0xd6, 0x12, 0x63, 0x6f, 0xcf, 0x19,
	0xfb, 0x4f, 0x02, 0xbb, 0x55, 0x63, 0xff, 0xd7, 0xce, 0xf7, 0x58, 0x5f, 0xff, 0x31, 0x1e, 0xcb,
	0xf1, 0x68, 0x04, 0xbb, 0x07, 0x31, 0x32, 0x51, 0x7f, 0x1c, 0xd3, 0x10, 0x4e, 0x1d, 0xa1, 0xd2,
	0x29, 0x5c, 0x27, 0x0a, 0xc2, 0xff, 0xae, 0xb3, 0x88, 0x2b, 0x16, 0xd5, 0x7a, 0x3f, 0xdf, 0x81,
	0x9d, 0x1b, 0x22, 0x9d, 0x44, 0xb2, 0xe6, 0x3e, 0x40, 0x57, 0xe6, 0x62, 0x26, 0xaa, 0x33, 0x34,
	0x16, 0x95, 0xc0, 0x2e, 0x34, 0x33, 0x26, 0x58, 0xf2, 0xb6, 0x6b, 0x59, 0x9d, 0x54, 0xe8, 0x2f,
	0xb9, 0x3e, 0xdb, 0x49, 0xf4, 0x11, 0xec, 0x98, 0x5e, 0x4c, 0x37, 0x94, 0x6b, 0xe6, 0xaa, 0xa3,
	0x6b, 0xc0, 0x65, 0x86, 0xa3, 0x5a, 0x3b, 0xc1, 0x2f, 0x36, 0xa0, 0xeb, 0xe6, 0x87, 0x62, 0x00,
	0xab, 0xf1, 0xa0, 0xcf, 0x19, 0x80, 0x92, 0x34, 0xc4, 0xd8, 0xf8, 0xa5, 0x15, 0x58, 0x41, 0x67,
	0xf7, 0x48, 0x8c, 0x8c, 0x4f, 0x5a, 0x81, 0x5e, 0x9a, 0xf7, 0xd8, 0xbd, 0x54, 0xb8, 0x5a, 0x64,
	0x05, 0xa3, 0x8d, 0x78, 0x2a, 0x5c, 0x25, 0xb2, 0x82, 0xee, 0xe3, 0x27, 0x28, 0x74, 0x3c, 0x9b,
	0x4f, 0x0b, 0x5e, 0x30, 0x15, 0xcd, 0xd0, 0x1c, 0x3d, 0x42, 0x1f, 0xdc, 0xd0, 0x1c, 0x3d, 0x42,
	0xfa, 0x19, 0x81, 0xb3, 0x76, 0xf4, 0x3c, 0x46, 0x3b, 0xd0, 0xbf, 0x08, 0xec, 0xea, 0xf1, 0xf3,
	0x38, 0x7d, 0x31, 0xb5, 0x8e, 0x57, 0x5a, 0xa7, 0x1c, 0x50, 0x9b, 0xd5, 0x01, 0x75, 0xf6, 0x9b,
	0xc8, 0xd6, 0xd2, 0x6f, 0x22, 0xdb, 0x95, 0x6f, 0x22, 0xb6, 0x7b, 0x2d, 0xbf, 0x75, 0xd5, 0x3c,
	0x05, 0x5c, 0x1e, 0x3d, 0xc8, 0x23, 0x81, 0xeb, 0xc1, 0xfb, 0x9a, 0xc0, 0x49, 0x3b, 0x81, 0xd6,
	0xdc, 0x72, 0x86, 0xb9, 0x28, 0xff, 0x1a, 0xf0, 0x82, 0x42, 0xae, 0xce, 0xae, 0xde, 0xcc, 0xec,
	0x7a, 0xa5, 0xfd, 0xeb, 0xd3, 0x1e, 0xf9, 0xed, 0x69, 0x8f, 0xfc, 0xfd, 0xb4, 0x47, 0x86, 0x4d,
	0xf3, 0xb7, 0xd9, 0x3b, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x70, 0xd9, 0xf2, 0x8e, 0x5e, 0x1b,
	0x00, 0x00,
}

func (m *ByeMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ByeMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ByeMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LinkStatusMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkStatusMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkStatusMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LinkStatesMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LinkStatesMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LinkStatesMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.States) > 0 {
		i -= len(m.States)
		copy(dAtA[i:], m.States)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.States)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GeneralStatusMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeneralStatusMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeneralStatusMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x2a
	}
	if m.DataLength != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.DataLength))
		i--
		dAtA[i] = 0x20
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DataLength != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.DataLength))
		i--
		dAtA[i] = 0x30
	}
	if m.Severity != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x28
	}
	if m.Type != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceInformationMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceInformationMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceInformationMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Information) > 0 {
		i -= len(m.Information)
		copy(dAtA[i:], m.Information)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Information)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceSettingsMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceSettingsMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceSettingsMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Settings) > 0 {
		i -= len(m.Settings)
		copy(dAtA[i:], m.Settings)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Settings)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceMultipartSettingsMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceMultipartSettingsMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceMultipartSettingsMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SegmentIndex != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SegmentIndex))
		i--
		dAtA[i] = 0x30
	}
	if m.NumberOfSegments != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.NumberOfSegments))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Settings) > 0 {
		i -= len(m.Settings)
		copy(dAtA[i:], m.Settings)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Settings)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceSettingsResponseMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceSettingsResponseMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceSettingsResponseMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GeneralResponseMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GeneralResponseMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GeneralResponseMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x32
	}
	if m.DataLength != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.DataLength))
		i--
		dAtA[i] = 0x28
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x20
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PullSettingsMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PullSettingsMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PullSettingsMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PullWsnSettingsMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PullWsnSettingsMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PullWsnSettingsMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SensorDataMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SensorDataMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SensorDataMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			f1 := math.Float32bits(float32(m.Values[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f1))
		}
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Values)*4))
		i--
		dAtA[i] = 0x3a
	}
	if m.Length != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x30
	}
	if m.Usec != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Usec))
		i--
		dAtA[i] = 0x28
	}
	if m.SensorId != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SensorId))
		i--
		dAtA[i] = 0x20
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LargeSensorDataMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LargeSensorDataMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LargeSensorDataMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x4a
	}
	if m.DataLength != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.DataLength))
		i--
		dAtA[i] = 0x40
	}
	if m.MetaLength != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.MetaLength))
		i--
		dAtA[i] = 0x38
	}
	if m.NumSegments != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.NumSegments))
		i--
		dAtA[i] = 0x30
	}
	if m.SegmentId != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SegmentId))
		i--
		dAtA[i] = 0x28
	}
	if m.SessionId != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SessionId))
		i--
		dAtA[i] = 0x20
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContinuousDataMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContinuousDataMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContinuousDataMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DataLength != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.DataLength))
		i--
		dAtA[i] = 0x30
	}
	if m.Usec != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Usec))
		i--
		dAtA[i] = 0x28
	}
	if m.SensorId != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SensorId))
		i--
		dAtA[i] = 0x20
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CalibrateStatusMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalibrateStatusMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CalibrateStatusMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			f2 := math.Float32bits(float32(m.Values[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f2))
		}
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Values)*4))
		i--
		dAtA[i] = 0x32
	}
	if m.Length != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x28
	}
	if m.Step != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Step))
		i--
		dAtA[i] = 0x20
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FirmwareUpgradeResponseMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirmwareUpgradeResponseMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FirmwareUpgradeResponseMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FirmwareCancelResponseMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirmwareCancelResponseMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FirmwareCancelResponseMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FirmwareLoadStatusMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirmwareLoadStatusMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FirmwareLoadStatusMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Progress != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Progress))))
		i--
		dAtA[i] = 0x35
	}
	if m.SeqId != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SeqId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FirmwareUpgradeStatusMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FirmwareUpgradeStatusMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FirmwareUpgradeStatusMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Progress != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Progress))))
		i--
		dAtA[i] = 0x2d
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceStatusMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceStatusMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceStatusMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TunnelDataMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelDataMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelDataMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x22
	}
	if m.Code != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x18
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RebootCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RebootCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RebootCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResetCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetDeviceInformationCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDeviceInformationCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDeviceInformationCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetDeviceStatusCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDeviceStatusCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDeviceStatusCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetDeviceSettingsCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDeviceSettingsCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDeviceSettingsCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetLinkStatusCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLinkStatusCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLinkStatusCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetLinkStatesCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLinkStatesCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLinkStatesCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateDeviceSettingsCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateDeviceSettingsCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateDeviceSettingsCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastUpdateTime != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.LastUpdateTime))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Settings) > 0 {
		i -= len(m.Settings)
		copy(dAtA[i:], m.Settings)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Settings)))
		i--
		dAtA[i] = 0x22
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateWsnCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateWsnCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateWsnCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastUpdateTime != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.LastUpdateTime))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Settings) > 0 {
		i -= len(m.Settings)
		copy(dAtA[i:], m.Settings)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Settings)))
		i--
		dAtA[i] = 0x22
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ModbusId != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.ModbusId))
		i--
		dAtA[i] = 0x28
	}
	if m.Type != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ParentMac) > 0 {
		i -= len(m.ParentMac)
		copy(dAtA[i:], m.ParentMac)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ParentMac)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Mac) > 0 {
		i -= len(m.Mac)
		copy(dAtA[i:], m.Mac)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Mac)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateDevicesCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateDevicesCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateDevicesCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTheta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddDeviceCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddDeviceCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddDeviceCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ModbusId != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.ModbusId))
		i--
		dAtA[i] = 0x40
	}
	if m.Type != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ParentMac) > 0 {
		i -= len(m.ParentMac)
		copy(dAtA[i:], m.ParentMac)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ParentMac)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Mac) > 0 {
		i -= len(m.Mac)
		copy(dAtA[i:], m.Mac)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Mac)))
		i--
		dAtA[i] = 0x22
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateDeviceCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateDeviceCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateDeviceCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ModbusId != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.ModbusId))
		i--
		dAtA[i] = 0x40
	}
	if m.Type != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ParentMac) > 0 {
		i -= len(m.ParentMac)
		copy(dAtA[i:], m.ParentMac)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ParentMac)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Mac) > 0 {
		i -= len(m.Mac)
		copy(dAtA[i:], m.Mac)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Mac)))
		i--
		dAtA[i] = 0x22
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteDeviceCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteDeviceCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteDeviceCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Mac) > 0 {
		i -= len(m.Mac)
		copy(dAtA[i:], m.Mac)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Mac)))
		i--
		dAtA[i] = 0x22
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClearDevicesCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearDevicesCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearDevicesCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SetTimeCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetTimeCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetTimeCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MaintainCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaintainCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MaintainCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProvisionCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProvisionCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProvisionCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CalibrateCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CalibrateCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CalibrateCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Param2 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Param2))))
		i--
		dAtA[i] = 0x35
	}
	if m.Param1 != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Param1))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Type != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResetDataCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResetDataCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResetDataCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Type != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InspectCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpgradeFirmwareCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpgradeFirmwareCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpgradeFirmwareCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Size_ != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x50
	}
	if m.Version != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x48
	}
	if m.Minor != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Minor))
		i--
		dAtA[i] = 0x40
	}
	if m.Major != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Major))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Crc) > 0 {
		i -= len(m.Crc)
		copy(dAtA[i:], m.Crc)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Crc)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Model) > 0 {
		i -= len(m.Model)
		copy(dAtA[i:], m.Model)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Model)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0x22
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CancelFirmwareCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelFirmwareCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelFirmwareCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0x22
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LoadFirmwareCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadFirmwareCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoadFirmwareCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x42
	}
	if m.DataLength != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.DataLength))
		i--
		dAtA[i] = 0x38
	}
	if m.SeqId != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SeqId))
		i--
		dAtA[i] = 0x30
	}
	if m.Size_ != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x28
	}
	if len(m.TaskId) > 0 {
		i -= len(m.TaskId)
		copy(dAtA[i:], m.TaskId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.TaskId)))
		i--
		dAtA[i] = 0x22
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetSensorDataCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetSensorDataCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetSensorDataCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AcquireSensorDataCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcquireSensorDataCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcquireSensorDataCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TunnelCommand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TunnelCommand) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TunnelCommand) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Duration != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x20
	}
	if m.SubCommand != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.SubCommand))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReqId) > 0 {
		i -= len(m.ReqId)
		copy(dAtA[i:], m.ReqId)
		i = encodeVarintTheta(dAtA, i, uint64(len(m.ReqId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Timestamp != 0 {
		i = encodeVarintTheta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTheta(dAtA []byte, offset int, v uint64) int {
	offset -= sovTheta(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ByeMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LinkStatusMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LinkStatesMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	l = len(m.States)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GeneralStatusMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	if m.DataLength != 0 {
		n += 1 + sovTheta(uint64(m.DataLength))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EventMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	if m.Type != 0 {
		n += 1 + sovTheta(uint64(m.Type))
	}
	if m.Severity != 0 {
		n += 1 + sovTheta(uint64(m.Severity))
	}
	if m.DataLength != 0 {
		n += 1 + sovTheta(uint64(m.DataLength))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceInformationMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	l = len(m.Information)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceSettingsMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	l = len(m.Settings)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceMultipartSettingsMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	l = len(m.Settings)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.NumberOfSegments != 0 {
		n += 1 + sovTheta(uint64(m.NumberOfSegments))
	}
	if m.SegmentIndex != 0 {
		n += 1 + sovTheta(uint64(m.SegmentIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceSettingsResponseMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GeneralResponseMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	if m.DataLength != 0 {
		n += 1 + sovTheta(uint64(m.DataLength))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PullSettingsMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PullWsnSettingsMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SensorDataMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	if m.SensorId != 0 {
		n += 1 + sovTheta(uint64(m.SensorId))
	}
	if m.Usec != 0 {
		n += 1 + sovTheta(uint64(m.Usec))
	}
	if m.Length != 0 {
		n += 1 + sovTheta(uint64(m.Length))
	}
	if len(m.Values) > 0 {
		n += 1 + sovTheta(uint64(len(m.Values)*4)) + len(m.Values)*4
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LargeSensorDataMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	if m.SessionId != 0 {
		n += 1 + sovTheta(uint64(m.SessionId))
	}
	if m.SegmentId != 0 {
		n += 1 + sovTheta(uint64(m.SegmentId))
	}
	if m.NumSegments != 0 {
		n += 1 + sovTheta(uint64(m.NumSegments))
	}
	if m.MetaLength != 0 {
		n += 1 + sovTheta(uint64(m.MetaLength))
	}
	if m.DataLength != 0 {
		n += 1 + sovTheta(uint64(m.DataLength))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContinuousDataMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	if m.SensorId != 0 {
		n += 1 + sovTheta(uint64(m.SensorId))
	}
	if m.Usec != 0 {
		n += 1 + sovTheta(uint64(m.Usec))
	}
	if m.DataLength != 0 {
		n += 1 + sovTheta(uint64(m.DataLength))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CalibrateStatusMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	if m.Step != 0 {
		n += 1 + sovTheta(uint64(m.Step))
	}
	if m.Length != 0 {
		n += 1 + sovTheta(uint64(m.Length))
	}
	if len(m.Values) > 0 {
		n += 1 + sovTheta(uint64(len(m.Values)*4)) + len(m.Values)*4
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirmwareUpgradeResponseMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirmwareCancelResponseMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirmwareLoadStatusMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SeqId != 0 {
		n += 1 + sovTheta(uint64(m.SeqId))
	}
	if m.Progress != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FirmwareUpgradeStatusMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Progress != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceStatusMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TunnelDataMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	if m.Code != 0 {
		n += 1 + sovTheta(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RebootCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResetCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetDeviceInformationCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetDeviceStatusCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetDeviceSettingsCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLinkStatusCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLinkStatesCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateDeviceSettingsCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	l = len(m.Settings)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.LastUpdateTime != 0 {
		n += 1 + sovTheta(uint64(m.LastUpdateTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateWsnCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	l = len(m.Settings)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.LastUpdateTime != 0 {
		n += 1 + sovTheta(uint64(m.LastUpdateTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeviceItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	l = len(m.ParentMac)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTheta(uint64(m.Type))
	}
	if m.ModbusId != 0 {
		n += 1 + sovTheta(uint64(m.ModbusId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateDevicesCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTheta(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddDeviceCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	l = len(m.ParentMac)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTheta(uint64(m.Type))
	}
	if m.ModbusId != 0 {
		n += 1 + sovTheta(uint64(m.ModbusId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateDeviceCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	l = len(m.ParentMac)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTheta(uint64(m.Type))
	}
	if m.ModbusId != 0 {
		n += 1 + sovTheta(uint64(m.ModbusId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteDeviceCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	l = len(m.Mac)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClearDevicesCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SetTimeCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MaintainCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProvisionCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CalibrateCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.Type != 0 {
		n += 1 + sovTheta(uint64(m.Type))
	}
	if m.Param1 != 0 {
		n += 5
	}
	if m.Param2 != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResetDataCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.Type != 0 {
		n += 1 + sovTheta(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpgradeFirmwareCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	l = len(m.Model)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	l = len(m.Crc)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Major != 0 {
		n += 1 + sovTheta(uint64(m.Major))
	}
	if m.Minor != 0 {
		n += 1 + sovTheta(uint64(m.Minor))
	}
	if m.Version != 0 {
		n += 1 + sovTheta(uint64(m.Version))
	}
	if m.Size_ != 0 {
		n += 1 + sovTheta(uint64(m.Size_))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CancelFirmwareCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LoadFirmwareCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	l = len(m.TaskId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovTheta(uint64(m.Size_))
	}
	if m.SeqId != 0 {
		n += 1 + sovTheta(uint64(m.SeqId))
	}
	if m.DataLength != 0 {
		n += 1 + sovTheta(uint64(m.DataLength))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetSensorDataCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AcquireSensorDataCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TunnelCommand) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovTheta(uint64(m.Timestamp))
	}
	l = len(m.ReqId)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.SubCommand != 0 {
		n += 1 + sovTheta(uint64(m.SubCommand))
	}
	if m.Duration != 0 {
		n += 1 + sovTheta(uint64(m.Duration))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovTheta(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTheta(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTheta(x uint64) (n int) {
	return sovTheta(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ByeMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ByeMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ByeMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkStatusMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkStatusMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkStatusMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LinkStatesMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LinkStatesMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LinkStatesMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.States = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeneralStatusMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeneralStatusMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeneralStatusMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLength", wireType)
			}
			m.DataLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLength", wireType)
			}
			m.DataLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceInformationMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceInformationMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceInformationMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Information", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Information = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceSettingsMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceSettingsMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceSettingsMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Settings = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceMultipartSettingsMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceMultipartSettingsMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceMultipartSettingsMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Settings = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfSegments", wireType)
			}
			m.NumberOfSegments = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfSegments |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentIndex", wireType)
			}
			m.SegmentIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentIndex |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceSettingsResponseMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceSettingsResponseMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceSettingsResponseMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GeneralResponseMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GeneralResponseMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GeneralResponseMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLength", wireType)
			}
			m.DataLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PullSettingsMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PullSettingsMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PullSettingsMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PullWsnSettingsMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PullWsnSettingsMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PullWsnSettingsMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SensorDataMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SensorDataMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SensorDataMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SensorId", wireType)
			}
			m.SensorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SensorId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usec", wireType)
			}
			m.Usec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Usec |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Values = append(m.Values, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheta
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTheta
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTheta
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Values) == 0 {
					m.Values = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Values = append(m.Values, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LargeSensorDataMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LargeSensorDataMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LargeSensorDataMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SegmentId", wireType)
			}
			m.SegmentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SegmentId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSegments", wireType)
			}
			m.NumSegments = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumSegments |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetaLength", wireType)
			}
			m.MetaLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MetaLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLength", wireType)
			}
			m.DataLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContinuousDataMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContinuousDataMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContinuousDataMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SensorId", wireType)
			}
			m.SensorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SensorId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Usec", wireType)
			}
			m.Usec = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Usec |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLength", wireType)
			}
			m.DataLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CalibrateStatusMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalibrateStatusMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalibrateStatusMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.Values = append(m.Values, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTheta
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTheta
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTheta
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.Values) == 0 {
					m.Values = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.Values = append(m.Values, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirmwareUpgradeResponseMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirmwareUpgradeResponseMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirmwareUpgradeResponseMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirmwareCancelResponseMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirmwareCancelResponseMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirmwareCancelResponseMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirmwareLoadStatusMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirmwareLoadStatusMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirmwareLoadStatusMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqId", wireType)
			}
			m.SeqId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Progress = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FirmwareUpgradeStatusMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FirmwareUpgradeStatusMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FirmwareUpgradeStatusMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Progress", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Progress = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceStatusMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceStatusMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceStatusMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelDataMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelDataMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelDataMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RebootCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RebootCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RebootCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDeviceInformationCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDeviceInformationCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDeviceInformationCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDeviceStatusCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDeviceStatusCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDeviceStatusCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDeviceSettingsCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDeviceSettingsCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDeviceSettingsCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLinkStatusCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLinkStatusCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLinkStatusCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLinkStatesCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLinkStatesCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLinkStatesCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateDeviceSettingsCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateDeviceSettingsCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateDeviceSettingsCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Settings = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			m.LastUpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdateTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateWsnCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateWsnCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateWsnCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Settings = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			m.LastUpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdateTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = append(m.Mac[:0], dAtA[iNdEx:postIndex]...)
			if m.Mac == nil {
				m.Mac = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentMac", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentMac = append(m.ParentMac[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentMac == nil {
				m.ParentMac = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModbusId", wireType)
			}
			m.ModbusId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModbusId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateDevicesCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateDevicesCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateDevicesCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &DeviceItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddDeviceCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddDeviceCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddDeviceCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = append(m.Mac[:0], dAtA[iNdEx:postIndex]...)
			if m.Mac == nil {
				m.Mac = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentMac", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentMac = append(m.ParentMac[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentMac == nil {
				m.ParentMac = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModbusId", wireType)
			}
			m.ModbusId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModbusId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateDeviceCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateDeviceCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateDeviceCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = append(m.Mac[:0], dAtA[iNdEx:postIndex]...)
			if m.Mac == nil {
				m.Mac = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentMac", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentMac = append(m.ParentMac[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentMac == nil {
				m.ParentMac = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = append(m.Name[:0], dAtA[iNdEx:postIndex]...)
			if m.Name == nil {
				m.Name = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModbusId", wireType)
			}
			m.ModbusId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModbusId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteDeviceCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteDeviceCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteDeviceCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mac", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mac = append(m.Mac[:0], dAtA[iNdEx:postIndex]...)
			if m.Mac == nil {
				m.Mac = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearDevicesCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearDevicesCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearDevicesCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetTimeCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetTimeCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetTimeCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaintainCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaintainCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaintainCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProvisionCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProvisionCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProvisionCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CalibrateCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CalibrateCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CalibrateCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param1", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Param1 = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Param2", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Param2 = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResetDataCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResetDataCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResetDataCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpgradeFirmwareCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpgradeFirmwareCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpgradeFirmwareCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Model = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Major", wireType)
			}
			m.Major = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Major |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minor", wireType)
			}
			m.Minor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelFirmwareCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelFirmwareCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelFirmwareCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadFirmwareCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadFirmwareCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadFirmwareCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TaskId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqId", wireType)
			}
			m.SeqId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataLength", wireType)
			}
			m.DataLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataLength |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetSensorDataCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetSensorDataCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetSensorDataCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcquireSensorDataCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcquireSensorDataCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcquireSensorDataCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TunnelCommand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TunnelCommand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TunnelCommand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReqId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubCommand", wireType)
			}
			m.SubCommand = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubCommand |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTheta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTheta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTheta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTheta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTheta(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTheta
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTheta
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTheta
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTheta
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTheta
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTheta        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTheta          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTheta = fmt.Errorf("proto: unexpected end of group")
)
